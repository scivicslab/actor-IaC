/*
 * Copyright 2025 devteam@scivics-lab.com
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
 * either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

package com.scivicslab.actoriac;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.util.logging.Logger;

import com.jcraft.jsch.ChannelExec;
import com.jcraft.jsch.JSch;
import com.jcraft.jsch.JSchException;
import com.jcraft.jsch.Session;
import com.scivicslab.pojoactor.workflow.Interpreter;
import com.scivicslab.pojoactor.workflow.IIActorSystem;

/**
 * Represents a single node in the infrastructure that can execute workflows.
 *
 * <p>This class extends {@link Interpreter} to combine SSH-based command execution
 * with workflow execution capabilities. Each Node instance can:</p>
 * <ul>
 *   <li>Execute commands on remote nodes via SSH</li>
 *   <li>Execute workflows defined in YAML/JSON/XML files</li>
 *   <li>Maintain independent workflow execution state (currentState, currentRow)</li>
 * </ul>
 *
 * <p>Supports Vault-based secret management for SSH keys and sudo passwords.</p>
 *
 * <p><b>Design rationale:</b> Node extends Interpreter rather than composing it because:</p>
 * <ul>
 *   <li>Node "is a" specialized Interpreter with SSH capabilities (is-a relationship)</li>
 *   <li>Each Node needs independent workflow execution state</li>
 *   <li>Simplifies ActorSystem registration (only one actor per node)</li>
 *   <li>Workflow YAML can reference "actor: node" unambiguously</li>
 * </ul>
 *
 * @author devteam@scivics-lab.com
 */
public class Node extends Interpreter {

    private final String hostname;
    private final String user;
    private final int port;
    private final String identityFile;
    private final String sshKeyContent;
    private final String sshPassphrase;
    private final String sudoPassword;

    /**
     * Constructs a Node with the specified connection parameters (POJO constructor).
     *
     * @param hostname the hostname or IP address of the node
     * @param user the SSH username
     * @param port the SSH port (typically 22)
     * @param identityFile the path to SSH private key file (can be null)
     */
    public Node(String hostname, String user, int port, String identityFile) {
        this(hostname, user, port, identityFile, null, null, null);
    }

    /**
     * Constructs a Node with Vault-provided secrets (POJO constructor).
     *
     * @param hostname the hostname or IP address of the node
     * @param user the SSH username
     * @param port the SSH port (typically 22)
     * @param identityFile the path to SSH private key file (can be null)
     * @param sshKeyContent SSH private key content from Vault (can be null)
     * @param sshPassphrase SSH key passphrase from Vault (can be null)
     * @param sudoPassword sudo password from Vault (can be null)
     */
    public Node(String hostname, String user, int port, String identityFile,
                String sshKeyContent, String sshPassphrase, String sudoPassword) {
        // Initialize Interpreter fields
        super();
        this.system = null;  // Will be set later if Node is converted to actor
        this.logger = Logger.getLogger("node-" + hostname);

        // Initialize Node-specific fields
        this.hostname = hostname;
        this.user = user;
        this.port = port;
        this.identityFile = identityFile;
        this.sshKeyContent = sshKeyContent;
        this.sshPassphrase = sshPassphrase;
        this.sudoPassword = sudoPassword;
    }

    /**
     * Constructs a Node with default port 22 and no identity file (POJO constructor).
     *
     * @param hostname the hostname or IP address of the node
     * @param user the SSH username
     */
    public Node(String hostname, String user) {
        this(hostname, user, 22, null);
    }

    /**
     * Sets the ActorSystem for workflow execution.
     * This should be called by IIActorRef when the Node is converted to an actor.
     *
     * @param system the actor system for workflow execution
     */
    public void setActorSystem(IIActorSystem system) {
        this.system = system;
    }

    /**
     * Executes a command on the remote node via SSH using JSch.
     *
     * @param command the command to execute
     * @return the execution result containing stdout, stderr, and exit code
     * @throws IOException if SSH connection or command execution fails
     */
    public CommandResult executeCommand(String command) throws IOException {
        Session session = null;
        ChannelExec channel = null;

        try {
            // Create JSch session
            session = createSession();
            session.connect();

            // Open exec channel
            channel = (ChannelExec) session.openChannel("exec");
            channel.setCommand(command);

            // Get streams
            InputStream stdout = channel.getInputStream();
            InputStream stderr = channel.getErrStream();

            // Connect channel
            channel.connect();

            // Read stdout
            StringBuilder stdoutBuilder = new StringBuilder();
            try (BufferedReader reader = new BufferedReader(new InputStreamReader(stdout))) {
                String line;
                while ((line = reader.readLine()) != null) {
                    stdoutBuilder.append(line).append("\n");
                }
            }

            // Read stderr
            StringBuilder stderrBuilder = new StringBuilder();
            try (BufferedReader reader = new BufferedReader(new InputStreamReader(stderr))) {
                String line;
                while ((line = reader.readLine()) != null) {
                    stderrBuilder.append(line).append("\n");
                }
            }

            // Wait for channel to close
            while (!channel.isClosed()) {
                try {
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                    throw new IOException("Command execution interrupted", e);
                }
            }

            int exitCode = channel.getExitStatus();

            return new CommandResult(
                stdoutBuilder.toString().trim(),
                stderrBuilder.toString().trim(),
                exitCode
            );

        } catch (JSchException e) {
            throw new IOException("SSH connection failed: " + e.getMessage(), e);
        } finally {
            if (channel != null && channel.isConnected()) {
                channel.disconnect();
            }
            if (session != null && session.isConnected()) {
                session.disconnect();
            }
        }
    }

    /**
     * Creates a JSch SSH session with configured credentials.
     *
     * @return configured but not yet connected Session
     * @throws JSchException if session creation fails
     * @throws IOException if SSH key file operations fail
     */
    private Session createSession() throws JSchException, IOException {
        JSch jsch = new JSch();

        // Add identity (SSH key)
        if (sshKeyContent != null && !sshKeyContent.isEmpty()) {
            // Use SSH key from Vault
            byte[] keyBytes = sshKeyContent.getBytes();
            byte[] passphraseBytes = (sshPassphrase != null) ? sshPassphrase.getBytes() : null;
            jsch.addIdentity(hostname, keyBytes, null, passphraseBytes);
        } else if (identityFile != null) {
            // Use SSH key from file
            if (sshPassphrase != null && !sshPassphrase.isEmpty()) {
                jsch.addIdentity(identityFile, sshPassphrase);
            } else {
                jsch.addIdentity(identityFile);
            }
        }

        // Create session
        Session session = jsch.getSession(user, hostname, port);

        // Disable strict host key checking (for convenience)
        // In production, you might want to make this configurable
        session.setConfig("StrictHostKeyChecking", "no");

        return session;
    }

    /**
     * Executes a command with sudo privileges on the remote node via SSH.
     *
     * <p>This method requires a sudo password to be configured (from Vault).
     * The password is supplied via stdin to sudo -S.</p>
     *
     * @param command the command to execute with sudo
     * @return the execution result containing stdout, stderr, and exit code
     * @throws IOException if SSH connection or command execution fails
     * @throws IllegalStateException if sudo password is not configured
     */
    public CommandResult executeSudoCommand(String command) throws IOException {
        if (sudoPassword == null || sudoPassword.isEmpty()) {
            throw new IllegalStateException(
                "Cannot execute sudo command: sudo password not configured. " +
                "Configure Vault integration to provide sudo password.");
        }

        // Use sudo -S to read password from stdin
        // The command format: echo 'password' | sudo -S command
        String sudoCommand = String.format("echo '%s' | sudo -S %s",
            escapeSingleQuotes(sudoPassword), command);

        return executeCommand(sudoCommand);
    }

    /**
     * Escapes single quotes in a string for use in shell commands.
     *
     * @param str the string to escape
     * @return the escaped string
     */
    private String escapeSingleQuotes(String str) {
        return str.replace("'", "'\\''");
    }

    /**
     * Cleans up resources used by this Node.
     * With JSch-based implementation, sessions are closed immediately after use,
     * so this method is a no-op but kept for API compatibility.
     */
    public void cleanup() {
        // No cleanup needed with JSch - sessions are closed in executeCommand()
    }

    /**
     * Gets the hostname of this node.
     *
     * @return the hostname
     */
    public String getHostname() {
        return hostname;
    }

    /**
     * Gets the SSH username for this node.
     *
     * @return the username
     */
    public String getUser() {
        return user;
    }

    /**
     * Gets the SSH port for this node.
     *
     * @return the port number
     */
    public int getPort() {
        return port;
    }

    /**
     * Gets the identity file path for this node.
     *
     * @return the identity file path, or null if not set
     */
    public String getIdentityFile() {
        return identityFile;
    }

    @Override
    public String toString() {
        return String.format("Node{hostname='%s', user='%s', port=%d}",
            hostname, user, port);
    }

    /**
     * Represents the result of a command execution.
     */
    public static class CommandResult {
        private final String stdout;
        private final String stderr;
        private final int exitCode;

        public CommandResult(String stdout, String stderr, int exitCode) {
            this.stdout = stdout;
            this.stderr = stderr;
            this.exitCode = exitCode;
        }

        public String getStdout() {
            return stdout;
        }

        public String getStderr() {
            return stderr;
        }

        public int getExitCode() {
            return exitCode;
        }

        public boolean isSuccess() {
            return exitCode == 0;
        }

        @Override
        public String toString() {
            return String.format("CommandResult{exitCode=%d, stdout='%s', stderr='%s'}",
                exitCode, stdout, stderr);
        }
    }
}
